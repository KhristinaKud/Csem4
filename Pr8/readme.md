## Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
### [Код](Pr81.c)
## Результат компіляції 
```text
kristi@host:~/pr/Pr8 $ gcc Wall Pr81.c -o  Pr81 
kristi@host:~/pr/Pr8$/Pr81 
Requested to write: 100000 bytes
Actually written: 100000 bytes
```
## Пояснення 
Так, виклик write(fd, buffer, nbytes); може повернути менше байтів, ніж вказано в nbytes, тому що функція write не гарантує, що весь запитаний об'єм даних буде записано за один виклик.Це притаманно, якщо немає пам'яті на диску, якщо це сокети або ж файл відкрито з прапором O_NONBLOCK.

Ця програма демонструє заповнення файлу.На початку програми відкривається файл "test.txt" для запису.Якщо відкриття не вдається, функція open() повертає -1, і програма виводить повідомлення про помилку та завершується.Після цього програма виділяє пам'ять у розмірі 100000 байтів за допомогою malloc(). Якщо виділення пам'яті зазнає невдачі, код завершується, закриваючи відкритий файл. Виділений блок пам'яті заповнюється символами 'A' за допомогою функції memset(). Таким чином, в пам'яті формується послідовність із 100000 символів 'A'.Далі програма виконує запис цього блоку даних у файл за допомогою системного виклику , який повертає кількість байтів, що були успішно записані.  Якщо запис проходить успішно, програма порівнює, скільки байтів було заплановано записати, і скільки дійсно було записано, виводячи цю інформацію користувачу.

---

## Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів: lseek(fd, 3, SEEK_SET); read(fd, &buffer, 4); де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
### [Код](Pr82.c)
## Результат компіляції 
```text
kristi @host:~/pr/Pr8 $ gcc Wall Pr82.c -o Pr82 
kristi @host:~/pr/P8 $/Pr82
Read 4 bytes: 2 3 3 7
```
## Пояснення 
Виклик lseek(fd, 3, SEEK_SET) переміщує файловий покажчик на третій байт файлу. Виклик read(fd, &buffer, 4) зчитує 4 байти, починаючи з позиції 3, тобто байти 2 3 3 7
Ця програма відкриває файл із назвою data.bin.Далі визначається масив data, що містить 10 значень . Цей масив записується у файл за допомогою виклику write(fd, data, 10).Після запису, за допомогою функції lseek(fd, 3, SEEK_SET) файловий курсор встановлюється на позицію з індексом 3. Таким чином, наступне зчитування почнеться з четвертого байту файлу.Після переміщення курсора, програма оголошує масив buffer для зберігання 4 байтів і виконує зчитування з файлу за допомогою read(fd, buffer, 4). 

---

##  Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
## Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
## Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
### [Код](Pr83.c)
## Результат компіляції 
```text
kristi @host:~/pr/Pr8 $ gcc Wall Pr83.c -o Pr83
kristi @host:~/pr/P8 $/Pr83
Test: Sorted:
  Time of sorting: 0.48900
  Sorting is corect: yes
Test: Reverse sorted:
  Time of sorting: 0.45200
  Sorting is corect: yes
Test: Random:
  Time of sorting: 1.09800
  Sorting is corect: yes
```
## Пояснення 
Ця програма має функції для генерації масиву в трьох варіантах: вже відсортований , відсортований у зворотному порядку  та заповнений випадковими значеннями .Для порівняння елементів використовується функція compare(), яка повертає різницю між двома цілими числами, що дозволяє визначити порядок сортування. Після сортування, окрема функція sorted() перевіряє, чи впорядкований масив, перебираючи послідовні елементи та впевнюючись, що кожен попередній не більше наступного.Усередині test_sort() виділяється пам’ять для масиву, дані заповнюються відповідно до вибраного сценарію, після чого розпочинається замір часу перед викликом qsort(). Після сортування програма обчислює, скільки часу це зайняло, і виводить на екран як час сортування, так і інформацію про те, чи вдалося відсортувати масив правильно.Основна функція main() ініціалізує генератор випадкових чисел і послідовно викликає test_sort() для кожного з трьох сценаріїв. 

---

## Виконайте наступну програму на мові програмування С:
```text
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
```
## Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

### [Код](Pr84.c)
## Результат компіляції 
```text
kristi @host:~/pr/Pr8 $ gcc Wall Pr84.c -o Pr84
kristi @host:~/pr/P8 $/Pr84
I am the parent: 15266
I am the child:0 
```
## Пояснення 
Ця програма  виконує виклик fork(), який створює новий процес. У батьківському процесі, fork() повертає ідентифікатор (PID) створеного дочірнього процесу, а у дочірньому — повертає 0. Код перевіряє значення, яке повернулось з fork(), і якщо воно менше нуля, то виводиться повідомлення про помилку. Якщо значення дорівнює 0, це означає, що ми опинилися в дочірньому процесі. В іншому випадку, тобто у батьківському процесі, виводиться ідентифікатор дочірнього процесу, який є числом, відмінним від нуля. Після цього обидва процеси виконують друк значення змінної pid: у дочірньому процесі буде надруковано 0, а в батьківському — ідентифікатор дочірнього процесу. Порядок виведення повідомлень залежить від того, як процесор розподіляє час між процесами, тому їх можна побачити в різному порядку
Тобто, батьківський процес отримує PID дочірнього процесу, а дочірній процес отримує 0, що дозволяє їм розрізняти свою поведінку.

---

## Завдання 9.(Проведіть тестування: що буде, якщо виконати fork() усередині циклу for із затримкою між викликами?)
### [Код](Pr89.c)
## Результат компіляції 
```text
kristi @host:~/pr/Pr8 $ gcc Wall Pr89.c -o Pr89
kristi @host:~/pr/P8 $/Pr89
Iam the parent 1 PID: 15295
I am the child 1 PID: 15296 
I am the parent 2 PID: 15295 
I am the child 2 PID: 15297 
I am the parent 3 PID: 15295 
I am the child 3 PID: 15298 
I am the parent 4 PID: 15295 
I am the child 4 PID: 15299 
I am the parent 5 PID: 15295 
I am the child 5 PID: 15300 
I am the parent 6 PID: 15295 
I am the child 6 PID: 15301 
I am the parent 7 PID: 15295 
I am the child 7 PID: 15302 
The finished
```
## Пояснення 
Відповідь на питання: Якщо дочірній процес завершується то  програма коректно завершиться з дочірніми процесами.Якщо дочірній процес не завершується відбудеться експоненційне розгалуження процесів, що може призвести до збою системи.

Ця програма завершується у дочірньому процесі.При кожному виклику fork() створюється новий дочірній процес. У дочірньому процесі (де fork повертає 0) виводиться повідомлення з номером ітерації та його власним PID, після чого процес завершує свою роботу за допомогою exit(0). У батьківському процесі виводиться повідомлення з номером ітерації та PID батьківського процесу, а потім цикл продовжується. Отже, з кожною секундою створюється новий дочірній процес, і в результаті програма створює дочірні процеси послідовно з інтервалом у 1 секунду. Після завершення циклу батьківський процес входить у цикл очікування, де він зупиняється, доки всі створені дочірні процеси не завершаться, після чого виводить фінальне повідомлення . 

