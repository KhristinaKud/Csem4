# Використайте popen(), щоб передати вивід команди rwho (команда UNIX) до more (команда UNIX) у програмі на C.
### [Код](Pr71.c)
## Результат компіляції 
```text
kristi@host:~/pr/Pr7 $ gcc Wall Pr71.c -o  Pr71 
kristi@host:~/pr/Pr7$/Pr71 
kristi @host:~/pr/Pr7 $
```
## Пояснення 
Програма виконує команду "rwho | more" через popen,відкриваючи канал для читання виводу цієї команди,rwho показує список підключених користувачів до системи, more - для перегляду тексту частинами. Якщо відкриття не вдалося, виводиться повідомлення про помилку, і програма завершується.
Після виконання команди і отримання її виводу, канал закривається через pclose(), а програма завершується. В результаті користувач побачить список  користувачів, розбитий на сторінки для зручного перегляду. Однак вона не зчитує жодних даних з цього потоку, тому стандартний вивід залишається порожнім.

---

#  Напишіть програму, яка друкує рядки з файлу, що містять слово, передане як аргумент програми (проста версія утиліти grep в UNIX).
### [Код](Pr73.c)
## Результат компіляції 
 - Файловий текст
```text
mama
mama
papa
papa
mama
papa
mama
```
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc Wall Pr73.c -o Pr73 
kristi @host:~/pr/Pr7$/Pr73 text Pr73.txt mama 
mama 
mama 
mama 
mama 
```
## Пояснення 
Ця програма шукає задане слово в текстовому файлі та виводить рядки, у яких це слово присутнє.Спочатку перевіряється кількість аргументів командного рядка. Якщо користувач ввів неправильну кількість параметрів, програма виведе повідомлення про правильний синтаксис використання і завершиться.Потім відкривається файл для читання. Якщо файл не вдалося відкрити , програма виведе повідомлення про помилку і завершиться.Далі програма читає файл рядок за рядком у буфер . Для кожного прочитаного рядка перевіряється, чи містить він задане слово. Якщо слово знайдено, рядок виводиться на екран.В результаті користувач побачить лише ті рядки файлу, які містять шукане слово. Якщо таких рядків немає, виводу не буде.

---

#  Напишіть програму, яка виводить список файлів, заданих у вигляді аргументів, з зупинкою кожні 20 рядків, доки не буде натиснута клавіша (спрощена версія утиліти more в UNIX).
### [Код](Pr74.c)
## Результат компіляції 
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc Wall Pr74.c -o Pr74
kristi @host:~/pr/Pr7$/Pr74 Pr741.txt Pr742.txt
File: Pr741.txt
1text
2text
3text
4text
...
19text
20text
--Press Enter to continue--
21text
...
24text

File: Pr742.txt
1text
2text
3text
4text
...
19text
20text
--Press Enter to continue--
21text
...
24text
```
## Пояснення 
Ця програма зроблена для перегляду текстових файлів, виводячи їх вміст порціями по 20 рядків. Якщо файл містить більше рядків, програма призупиняє вивід і чекає, поки користувач натисне Enter, перш ніж продовжити.Спочатку функція view_file() відкриває файл для читання. Якщо файл не вдалося відкрити ,виводиться повідомлення про помилку.Програма читає рядки з файлу за допомогою fgets() і виводить їх на екран. Лічильник рядків  відстежує, скільки вже було виведено. Як тільки він досягає LINES , програма виводить повідомлення "-- Press Enter to continue --" і зупиняється, поки користувач не натисне Enter. Після цього лічильник скидається до нуля, і вивід триває.Головна функція main() перевіряє, чи користувач передав хоча б один файл у командному рядку. Якщо ні, програма виведе правильний формат використання.Якщо є файли, вони обробляються по черзі в циклі (for). Для кожного файлу викликається view_file().У підсумку користувач побачить вміст файлу, зручний для перегляду—порціями по 20 рядків. Це особливо корисно для великих файлів, коли потрібно зупинятися, щоб переглянути дані.

---

# Напишіть програму, яка перелічує всі файли в поточному каталозі та всі файли в підкаталогах.
### [Код](Pr75.c)
## Результат компіляції 
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc Wall Pr75.c -o Pr75
kristi @host:~/pr/Pr7$/Pr75 
Directory : 
/Pr71.c 
/Pr72.с 
/Pr73.с 
/Pr74.c 
/Pr71 
/ Pr72 
/Pr73 
/text Pr72.txt 
/Pr74 
/Pr742.txt 
/Pr741.txt 
```
## Пояснення 
Ця програма рекурсивно переглядає вміст директорії , виводячи список файлів.Спочатку функція list_files() відкриває зазначену директорію . Якщо відкриття не вдалося, виводиться повідомлення про помилку.Далі програма читає вміст директорії по черзі. Вона ігнорує записи "." та "..", які відповідають поточній та батьківській директорії.Для кожного знайденого елемента формується повний шлях  і перевіряється його статус . Якщо елемент є директорією, функція list_files() викликається рекурсивно, щоб обробити її вміст. Якщо це файл, його шлях просто виводиться на екран.Функція main() запускає list_files() для поточної директорії ("."), виводячи список усіх файлів у ній та її вкладених директоріях.У підсумку користувач побачить список файлів у поточній директорії.

---

# Напишіть програму, яка показує користувачу всі його/її вихідні програми на C, а потім в інтерактивному режимі запитує, чи потрібно надати іншим дозвіл на читання (read permission); у разі ствердної відповіді — такий дозвіл повинен бути наданий.
### [Код](Pr77.c)
## Результат компіляції 
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc Wall Pr77.c -o Pr77
kristi @host:~/pr/Pr7$/Pr77
File: Pr71.c 
Grant read permission to others? (y/n): y Permissions updated 
File: Pr72.c 
Grant read permission to others? (y/n): n 
File: Pr73.c 
Grant read permission to others? (y/n): n 
File: Pr74.c 
Grant read permission to others? (y/n): n 
File: Pr9Z.c 
Grant read permission to others? (y/n): y 
Permissions updated. 
File: Pr77.c 
Grant read permission to others? (y/n): y 
Permissions updated 
File: Pr79.c 
Grant read permission to others? (y/n): y 
Permissions updated 
File: Pr710.C 
Grant read permission to others? (y/n): n
```
## Пояснення 
Ця програма проходить через усі файли у поточній директорії та шукає ті, що мають у своїй назві розширення .c. Спочатку вона намагається відкрити поточну директорію за допомогою функції. Якщо відкриття не вдається, виводиться повідомлення про помилку, і програма завершує виконання. Далі, за допомогою циклу та функції readdir(), програма послідовно перебирає кожен елемент у директорії. Для кожного файлу перевіряється, чи містить його ім'я рядок ".c". Якщо ім'я не містить цього підрядка, файл пропускається.Якщо файл є файлом на мові C, його ім’я виводиться на екран, після чого користувачу задається питання – чи бажає він надати іншим користувачам право на читання цього файлу. Відповідь зчитується,якщо користувач вводить "y", програма спочатку збирає інформацію про файл за допомогою функції stat(), щоб отримати поточний набір прав доступу, а потім викликає chmod(), додаючи до них біт S_IROTH, який дає право на читання для інших користувачів. Якщо операція зміни прав виконується успішно, в консоль виводиться повідомлення "Permissions updated"; у протилежному випадку виводиться повідомлення про помилку. Після обробки всіх файлів директорія закривається за допомогою closedir(), і програма завершує роботу.

---

#  Напишіть програму на C, яка вимірює час виконання фрагмента коду в мілісекундах.
### [Код](Pr9_Z.c)
## Результат компіляції 
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc Wall Pr9_Z.c -o Pr9_Z
kristi @host:~/pr/Pr7$/Pr9_Z
Execution time:166.00 ms
```
## Пояснення 
Ця програма виміряє, скільки часу займає проходження циклу з 100 мільйонами ітерацій, і потім виводить цей вимір у мілісекундах.У функції measure_time() створюються дві змінні типу struct timeval, які використовуються для збереження часу до запуску та після завершення циклу. Спочатку викликається функція gettimeofday(), щоб зафіксувати початковий момент часу в змінній start. Після цього виконується цикл for. Коли цикл закінчується, знову викликається gettimeofday(), але цього разу для зчитування кінцевого часу в змінній end.
Отримана різниця між кінцевим і початковим часом обчислюється. І  значення повертається як число типу double.У функції main() викликається measure_time(), і отриманий час зберігається у змінній. Час виводиться на екран . Таким чином, програма демонструє, як можна виміряти час виконання коду.

---

# Напишіть програму мовою C для створення послідовності випадкових чисел з плаваючою комою у діапазонах:
 (a) від 0.0 до 1.0
 (b) від 0.0 до n, де n — будь-яке дійсне число з плаваючою точкою.
 Початкове значення генератора випадкових чисел має бути встановлене так, щоб гарантувати унікальну послідовність.
Примітка: використання прапорця -Wall під час компіляції є обов’язковим.

### [Код](Pr710.c)
## Результат компіляції 
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc Wall Pr710.c -o Pr710
kristi @host:~/pr/Pr7$/Pr710
0.0 and 1.0: 
0.3525 
0.6079 
0.7867 
0.1281 
0.5609 
0.0 and 5.5: 
4.8825 
5.2448 
1.3163 
0.1543 
1.9186 
```
## Пояснення 
Ця програма генерує випадкові числа  у заданих діапазонах. Програма містить дві функції: перша  повертає випадкове число від 0 до 1, ділячи результат стандартної функції rand() на константу RAND_MAX, що забезпечує отримання числа з плаваючою комою між 0.0 і 1.0. Друга функція, використовує значення, повернуте rand_0_to_1, і множить його на передане значення n, таким чином генеруючи випадкове число від 0.0 до n. У функції main спочатку ініціалізується генератор випадкових чисел. Після цього програма спочатку виводить заголовок "0.0 and 1.0:" і за допомогою циклу виводить п’ять випадкових чисел, отриманих із функції rand_0_to_1. Далі встановлюється значення змінної n рівним 5.5, і, після виведення заголовку "0.0 and 5.5:", аналогічним циклом генеруються та виводяться п’ять випадкових чисел у діапазоні від 0.0 до 5.5 за допомогою функції rand_0_to_n. Таким чином, програма демонструє генерацію випадкових чисел у різних числових діапазонах і форматування їхнього виводу.

---

# Варіант 9 (Розробіть сканер портів у локальній мережі, який не використовує сокети або будь-які мережеві бібліотеки напряму.
)

### [Код](Pr79.c)
## Результат компіляції 
- Результат
```text
kristi @host:~/pr/Pr7 $ gcc - Wall Pr79.c Pr79 
kristi@host:~/pr/Pr7 $/Pr79 
Enter the IP address to scan: 10.0.2.15 
Enter the starting port (1-65535): 1 
Enter the final port (1-65535): 500 
Scan ports 1 - 5000 on host 10.0.2.15 
Connection to 10.02.15 22 port [tcp/ssh] succeeded! 
Port 22 is open 
kristi @host:~/pr/Pr7 $ gcc Wall Pr79.c -0 Pr79 
kristi @host:~/pr/Pr7 $/Pr79 
Enter the IP address to scan: 10.0.2.15 
Enter the starting port (1-65535): 500 
Enter the final port (1-65535): 1000 
Scan ports 500-1000 on host 10.02.15
Connection to 10.02.15 514 port [tcp/ssh] succeeded! 
Port 514 is open 
```
## Пояснення
Ця програма розроблена для сканування діапазону портів без використання сокетів або бібліотеки. Програма працює за допомогою утиліти nc (netcat). Спочатку користувачу пропонується ввести IP-адресу хоста, на якому потрібно провести сканування, а також вказати початковий і фінальний порти для перевірки. Програма перевіряє, чи правильно заданий діапазон портів(початковий порт не повинен перевищувати фінальний). Якщо користувач вводить невірні значення, програма повідомляє про помилку і завершує виконання.Після успішного введення даних програма виводить повідомлення про початок сканування вказаного діапазону портів на вказаному хості. Далі за допомогою циклу від початкового до фінального порту формується командний рядок, який використовує утиліту nc із параметрами -z та -w.Склеювання рядка відбувається за допомогою snprintf.Команда виконується через system(), а якщо її виконання повертає значення 0, це означає, що порт відкритий – і програма виводить відповідне повідомлення з номером порту. Таким чином, програма поступово перебирає всі порти в заданому діапазоні і інформує користувача про ті, що відкриті.
Виконуємо так: спочатку у термінал вводимо ifconfig щоб дізнатися локальну мережу. Далі netstat -an для перегляду відкритиx портів, завзвичай біля них пишеться listen. У мої мережі це *.22 та *.514
Перевіримо чи це так на програмі.Бачимо програма виводить порти які відкриті.
