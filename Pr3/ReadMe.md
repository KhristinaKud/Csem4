# Завдання 3.1
## Опис програми 
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку:
```text
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3001
$ ulimit -n 2000
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
```
## Результат Компіляції 
```text
test1@Ubuntu:~$ sudo docker run-it-rm ubuntu bash 
[sudo] password for test1: 
unknown flag: --it 
See 'docker run --help'. 
test1@Ubuntu:~$ ulimit -n 
1024 
test1@Ubuntu:~$ ulimit -as | grep "open files" 
open files                      (-n) 1024 
test1@Ubuntu:~$ ulimit -aH | grep "open files" 
open files                      (-n) 1048576 
test1@Ubuntu:~$ ulimit -n 3000 
test1@Ubuntu:~$ ulimit -as | grep "open files" 
open files                      (-n) 3000 
test1@Ubuntu:~$ ulimit -n 3001 
-bash: ulimit: open files: cannot modify limit: Operation not permitted 
test1@Ubuntu:~$ ulimit -n 2000 
test1@Ubuntu:~$ ulimit -n 
2000 
test1@Ubuntu:~$ ulimit -as | grep "open files" 
open files                      (-n) 2000 
test1@Ubuntu:~$ ulimit -aH | grep "open files" 
open files                      (-n) 2000 
test1@Ubuntu:~$ ulimit -n 3000 
-bash: ulimit: open files: cannot modify limit: Operation not permitted 
```
## Пояснення 
Отже, можна зробити висновок, що зміна лімітів з інтерактивним режимом, можлива тільки у бік зменшення, адже для їх підвищення недостатньо відповідних прав доступу.

---
# Завдання 3.2 
## Опис програми
У Docker-контейнері встановіть утиліту perf(1). Поекспериментуйте з досягненням процесом встановленого ліміту.
## Пояснення 
perf - це  інструмент для аналізу продуктивності в Linux. Він належить до ядра системи і дозволяє детально досліджувати роботу процесорів, пам'яті і т.д.
## Основні можливості perf:
-показує, які процеси найбільше навантажують процесор

-відстежує виділення, використання та помилки пам'яті

-аналізує, як програми взаємодіють із ядром

Що стосується перевантаження ядра, perf допомагає ідентифікувати програми, що споживають надмірну кількість оперативної пам’яті, CPU.Також виявляє, помилки у коді чи конфігурації системи, які призводять до цього.

---
# Завдання 3.3
## Опис програми
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.
## Компіляція
```bash
kristi @host:~/pr/Pr3 $ gcc - Wall Pr33.c -0 Pr 33 
kristi @host:~/pr/Pr3$ ./Pr33 
```
```text
File size limit reached. 
```
## Результат компілації у файлі
5 5 4 1 1 2 4 6 1 1 6 4 4 4 2 2 1 6 2 1 1 2 1 1 1 3 4 4 1 2
## Пояснення
Програма симулює кидки кубика, записуючи результати у файл. Випадкові числа від 1 до 6 генеруються функцією, а запис припиняється, якщо розмір файлу досягає 1024 байти. Файл відкривається для дописування, а після завершення роботи користувач отримує повідомлення "Досягнуто обмеження на розмір файлу".

---

# Завдання 3.4
## Опис програми
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.
## Компіляція
```bash
kristi @host:~/pr/Pr3 $ gcc - Wall Pr34.c -0 Pr 34
kristi @host:~/pr/Pr3$ ./Pr34
```
## Результат компілації
```text
Lottery numbers (149) 46 31 27 22 1 40 8 
Lottery numbers (136) 34 9 8 13 2 31 
Lottery numbers (149): 24 28 26 48 1 15 11 
numbers (1-8) 352828614825 25 Lottery numbers (136) 35 4 28 17 29 27 
CPU time limit exceeded (2 seconds). No further generation possible.
```
## Пояснення
Програма генерує лотерейні номери у двох форматах: 7 чисел (1–49) і 6 чисел (1–36), унікальних у кожному масиві. Випадкові числа генеруються за допомогою алгоритму перемішування масиву. Цикл триває до встановленого ліміту часу (2 секунди). Перевіряються дублікати, повторна генерація здійснюється за потреби. Результати виводяться в консоль із паузою в 1 секунду. Завершення супроводжується повідомленням про успішне завершення.

---

# Завдання 3.5
## Опис програми
Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.
Програма має:
 - перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments";
- перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading";
- перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing";
- обробляти ситуацію перевищення обмеження на розмір файлу.

## Компіляція
```bash
kristi @host:~/pr/Pr3 $ gcc - Wall Pr35.c -0 Pr 35
kristi @host:~/pr/Pr3$ ./Pr35 task35.txt copytask35.txt
```
## Результат компілації
```text
File copied successfully
```
Текст який скопіювався у файл
```text
Mama Hello World, Ukraine style
```
## Пояснення
Програма має два файли, один у якому є текст, другий якому має передатися копіюванням вміст першого файла. Є перевірки чи передано два аргументи,перевірено доступність першого файлу для читання,перевірено доступність другого файлу для запису,оброблено ситуацію перевищення обмеження на розмір файлу.Дані копіюються у буфер, який має обмеження розміру. Програма читає вміст першого файла частинами через fread та записує ці частини у другий файл  за допомогою fwrite. При цьому підраховується загальний розмір уже скопійованих даних. Якщо розмір файлу перевищує встановлений ліміт, видається повідомлення, і програма завершує копіювання, гарантуючи закриття обох файлів.

---

# Завдання 3.6
## Опис програми
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

## Компіляція
```bash
test1@Ubuntu:~$ ulimit -s 
8192
test1@Ubuntu:~$ ulimit -s 128 
test1@Ubuntu:~$ gcc task36.c -о task36 
```
## Результат компілації
```text
Recursion depth: 3890 
Recursion depth: 3891 
(Recursion depth: 3892 
Recursion depth: 3893 
Recursion depth: 3894 
Recursion depth: 3895 
Recursion depth: 3896 
Recursion depth: 3897 
Segmentation fault (core dumped)
```
## Пояснення
Проста реалізація коду для рекурсії. Встановлюємо ліміт для обмеження max stack segment size. І бачимо Segmentation fault (core dumped)

---


# Завдання 3.7 варіант 9
## Опис програми
Використати ulimit -d для обмеження динамічної пам’яті процесу.
## Компіляція
```bash
test1@Ubuntu:~$ gcc Pr37.c -о Pr37
test1@Ubuntu:~$ ulimit -d 1024
test1@Ubuntu:~$ ./Pr37
```
## Результат компілації
```text
Memory allocation failed at block 909
```
## Пояснення
Встановлюючи ліміт динамічної пам’яті через ulimit -d 1024,  програма завершує  на 909 КБ. Пояснити це можна резервами пам’яті та поведінкою malloc.Програма демонструє дію обмеження пам'яті.
