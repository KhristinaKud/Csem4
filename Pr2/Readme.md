# Завдання 2.1 
Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.
## [Код](Pr21.c)
## Опис програми 

Ця програма демонструє, як визначити максимальне значення типу даних time_t, а також як відобразити відповідний час у 32- та 64-бітної архітектурі.Результат має бути для 32-бітній 19 січня 2038 року, а для 64-бітній йде на мільярди роки

---
## Компіляція 
- Для 32-бітної системи:
  ```bash
  gcc -m32 -Wall task21.c -o task21
  ```
- Для 64-бітної системи:
  ```bash
  gcc -m64 -Wall task21.c -o task21
  ```
---
## Результат компіляції
- Для 32-бітної системи
```text
kristi@host:~/pr $ ./Pr21
Max value time_t: 2147483647
Time? when time_t finished: Tue Jan 19 03:14:07 2038
 ```
- Для 64-бітної системи
```text
kristi@host:~/pr $ ./Pr21
Max value time_t: 9223372036854775807
Error.
 ```
## Дослідження сегментів 

- Для 32-бітної системи 
```text
kristi @host:~/pr $ gccm3 2 - Wall Pr21.co Pr21.exe 
kristi @host:~/pr $ echo; echo "text data bss total" size Pr21
text data bss total 
text data bss dec hex filename 
1280 288    8 1576 628 Pr21
```
- Для 64-бітної системи
```text
kristi @host:~/pr $ gccm6 4 Wall Pr21.c0 Pr21.exe 
kristi @host:~/pr $ echo; echo "text data bss total" size Pr21.exe 
text data bss total 
text data bss dec hex filename 
1454 576 16 2046 7fe Pr21
```
---
## Висновки: можемо побачити що сегмент виконувального файлу  64-бітної  архітектури більше ніж 32-архітектури.
# Завдання 2.2 
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву(пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
6. Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.

## 1) Запустимо 


 
