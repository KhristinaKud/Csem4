# Завдання 2.1 
Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.
## [Код](Pr21.c)
## Опис програми 
Ця програма демонструє, як визначити максимальне значення типу даних time_t, а також як відобразити відповідний час у 32- та 64-бітної архітектурі.Результат має бути для 32-бітній 19 січня 2038 року, а для 64-бітній йде на мільярди роки

---
## Компіляція 
- Для 32-бітної системи:
  ```bash
  gcc -m32 -Wall task21.c -o task21
  ```
- Для 64-бітної системи:
  ```bash
  gcc -m64 -Wall task21.c -o task21
  ```
---
## Результат компіляції
- Для 32-бітної системи
```text
kristi@host:~/pr $ ./Pr21
Max value time_t: 2147483647
Time? when time_t finished: Tue Jan 19 03:14:07 2038
 ```
- Для 64-бітної системи
```text
kristi@host:~/pr $ ./Pr21
Max value time_t: 9223372036854775807
Error.
 ```
## Дослідження сегментів 

- Для 32-бітної системи 
```text
kristi @host:~/pr $ gccm3 2 - Wall Pr21.co Pr21.exe 
kristi @host:~/pr $ echo; echo "text data bss total" size Pr21
text data bss total 
text data bss dec hex filename 
1280 288    8 1576 628 Pr21
```
- Для 64-бітної системи
```text
kristi @host:~/pr $ gccm6 4 Wall Pr21.c0 Pr21.exe 
kristi @host:~/pr $ echo; echo "text data bss total" size Pr21.exe 
text data bss total 
text data bss dec hex filename 
1454 576 16 2046 7fe Pr21
```
---
## Висновки: можемо побачити що сегмент виконувального файлу  64-бітної  архітектури більше ніж 32-архітектури.
# Завдання 2.2 
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву(пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
6. Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.

---
## Умова 1
## [Код](Pr221.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr221.C -o Pr221 
Kristi @host:~/pr $/Pr221 
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr221 
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr221 
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 8192 Apr 3 19:02 Pr221
text  data  bss  dec  hex  filename
1078  552  16  1646  66e  Pr221  
```
## Умова 2
## [Код](Pr222.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr222.C -o Pr222
Kristi @host:~/pr $/Pr222
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr222
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr222 
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 8224 Apr 3 19:15 Pr222
text  data  bss  dec  hex  filename
1078  552  4032  5562  161e  Pr222
```
## Пояснення
Сегмент bbs збільшився на 4000 байт, тому що додавання глобального масиву до програми значно збільшує сегмент bss, оскільки масив займає пам'ять, яка виділяється для змінних.Кожен елемент займає 4байти.
## Умова 3
## [Код](Pr223.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr223.C -o Pr223
Kristi @host:~/pr $/Pr223
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr223
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr223 
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 12240 Apr 3 19:28 Pr223
text  data  bss  dec  hex  filename
1078  4568  16  5562  161e  Pr222
```
## Пояснення
Сегмент bbs має початкове значення, а сегмент data збылішилась на 4016 байт. Тобто масив з ініціалізацією перемістився з сигмента bss в сигмент data, що впливає на size файла.
## Умова 4
## [Код](Pr224.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr224.C -o Pr224
Kristi @host:~/pr $/Pr223
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr224
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr224
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 8232 Apr 3 19:35 Pr224
text  data  bss  dec  hex  filename
1118  552  16  1686  696  Pr224
```
## Пояснення
Локальні масиви завжди зберігаються у стеку під час виконання програми. Якщо масив не ініціалізований, пам'ять для нього просто виділяється у стеку, і це не впливає на розмір виконуваного файлу.
Проте, якщо масив ініціалізований, його початкові значення додаються до текстового сегмента виконуваного файлу. 
## Умова 5 
# Компіляція для налагодження 
```bash
gcc -g -o test1 Pr244.c
ls -l test1
size test1
```
# Компіляція для оптимізвції
```bash
gcc -o3 -o test1 Pr244.c
ls -l test2
size test2
```
# Результат
```text
- rwxr - xr - x 1 kristi kristi 8944 Apr 3 20:41 test1
text  data  bss  dec  hex  filename
1118  552  16  1686  696  test1
```
```text
- rwxr - xr - x 1 kristi kristi 8192 Apr 3 20:42 test2
text  data  bss  dec  hex  filename
1073  552  16  1641  669  test2
```
## Пояснення 
При налагодженні сегменти не змінились ,змінився розмір файлу, він збільшився. Макс. оптимізація зменшила розмір текстового сегмента
# Завдання 2.3  
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі. Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси. Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?
Примітка: стек може розташовуватися за різними адресами на різних архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями адрес.

---
- Скомпільована програма
## [Код](Pr231.c)
  ```text
 kristi @host:~/pr $/Pr231 
The stack top is near 0x821207c3c
  ```
- Знаходження розташування сегментів
## [Код](Pr232.c)
Результат компіляції
 ```text
kristi @host:~/pr $/Pr232 
Function address (text segment): 0x400612 
data segment: 0x401a48 
bss segment: 0x401a5c 
Heap allocation: 0x784c3808008 
Stack allocation: 0x820d391d4
 ```
- Збільшення розміру стека
  # [Код](Pr233.c)
  Результат компіляції
```text
kristi @host:~/pr $/Pr233 
Initial stack top: 0x820be148c 
Stack top inside function (arrayl): : 0x820be04d0 
Stack top inside function (array2): 0x820bdf530 
  ```
## Висновки: У коді з дослідженням різних сегментів пам'яті, можемо побачити як пам'ять використовується різними сегментами. У коді зі збільшенням розміру стека, бачимо що стек спускається(зростає) вниз, тому адреса зменшується
---
# Завдання 2.4
Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви можете:

● Автоматично за допомогою утиліти gstack.

● Вручну за допомогою налагоджувача GDB.
  # [Код](Pr24.c)
## Компіляція 
  ```bash
gcc -o Pr24 Pr24.c
  ```
## Результат програми 
```text
kristi@host:~/pr $ gcc-0 Pr24 Pr24.c 
kristi@host:~/pr $/Pr 24 
In function                            main; &local var = 0x820b0c1dc 
In function                           foo; &local va ar = 0x820b0clac 
In function                           bar; &local va ar = 0x820b0c18c 
In function             bar_is_now_closed; &local va ar = 0x820b0c16c 
Now blocking on pause()...
kristi @host:~/pr $ ps aux | grep [P]r24 0.0 0.2 
kristi 1258 0.0 0.2 12700 1736 0 | 00:38 0:00.00 /Pr24 
```
- bstack
```text
kristi@host:~/pr $ bstack 1258
Thread 1 (LWP 100547 of process 1258): 
#0 0x0000000823de76aa in sigsuspend () from /lib/libc.so.7 
#1 0x0000000823d5da65 in pause() from /lib/libc.so.7 
#2 0x000000000040068b in bar_is_now_closed () at Pr24.c: 11 
#3 0x00000000004006bd in bar () at Pr24.c: 17 
#4 0x00000000004006ef in foo ( ) at Pr24.c: 23 
#5 0x0000000000400728 in main (argc=1, argv=0x820fcfd08) at Pr24.c:29 
```
-GDB
```text
(gdb) backtrace 
#0 0x0000000823de76aa in _sigsuspend () from /lib/libc.so.7 
#1 0x000000 823 d5da65 in pause() from /lib/libc.so.7 
#2 0x0 0 0 0 0 0 0 0 0 0 4 0 0 68b in bar_is_now_closed () at Pr24.c: 11 
#3 0x00000000004006bd in bar () at Pr24.c: 17 
#4 0x00000000004006ef in foo() at Pr24.c:23 
#5 0x0000000000400728 in main (argc=1, argv=0x820fcfd08) at Pr24.c:29 
(gdb)
```



  

