# Завдання 2.1 
Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.
## [Код](Pr21.c)
## Опис програми 
Ця програма демонструє, як визначити максимальне значення типу даних time_t, а також як відобразити відповідний час у 32- та 64-бітної архітектурі.Результат має бути для 32-бітній 19 січня 2038 року, а для 64-бітній йде на мільярди роки

---
## Компіляція 
- Для 32-бітної системи:
  ```bash
  gcc -m32 -Wall task21.c -o task21
  ```
- Для 64-бітної системи:
  ```bash
  gcc -m64 -Wall task21.c -o task21
  ```
---
## Результат компіляції
- Для 32-бітної системи
```text
kristi@host:~/pr $ ./Pr21
Max value time_t: 2147483647
Time? when time_t finished: Tue Jan 19 03:14:07 2038
 ```
- Для 64-бітної системи
```text
kristi@host:~/pr $ ./Pr21
Max value time_t: 9223372036854775807
Error.
 ```
## Дослідження сегментів 

- Для 32-бітної системи 
```text
kristi @host:~/pr $ gccm3 2 - Wall Pr21.co Pr21.exe 
kristi @host:~/pr $ echo; echo "text data bss total" size Pr21
text data bss total 
text data bss dec hex filename 
1280 288    8 1576 628 Pr21
```
- Для 64-бітної системи
```text
kristi @host:~/pr $ gccm6 4 Wall Pr21.c0 Pr21.exe 
kristi @host:~/pr $ echo; echo "text data bss total" size Pr21.exe 
text data bss total 
text data bss dec hex filename 
1454 576 16 2046 7fe Pr21
```
---
## Висновки: можемо побачити що сегмент виконувального файлу  64-бітної  архітектури більше ніж 32-архітектури.
# Завдання 2.2 
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву(пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
6. Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.

---
## Умова 1
## [Код](Pr221.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr221.C -o Pr221 
Kristi @host:~/pr $/Pr221 
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr221 
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr221 
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 8192 Apr 3 19:02 Pr221
text  data  bss  dec  hex  filename
1078  552  16  1646  66e  Pr221  
```
## Умова 2
## [Код](Pr222.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr222.C -o Pr222
Kristi @host:~/pr $/Pr222
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr222
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr222 
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 8224 Apr 3 19:15 Pr222
text  data  bss  dec  hex  filename
1078  552  4032  5562  161e  Pr222
```
## Пояснення
Сегмент bbs збільшився на 4000 байт, тому що додавання глобального масиву до програми значно збільшує сегмент bss, оскільки масив займає пам'ять, яка виділяється для змінних.Кожен елемент займає 4байти.
## Умова 3
## [Код](Pr223.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr223.C -o Pr223
Kristi @host:~/pr $/Pr223
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr223
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr223 
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 12240 Apr 3 19:28 Pr223
text  data  bss  dec  hex  filename
1078  4568  16  5562  161e  Pr222
```
## Пояснення
Сегмент bbs має початкове значення, а сегмент data збылішилась на 4016 байт. Тобто масив з ініціалізацією перемістився з сигмента bss в сигмент data, що впливає на size файла.
## Умова 4
## [Код](Pr224.c)
## Компіляція 
- Компіляція програми
```bash
Kristi @host:~/pr $ gcc - Wall Pr224.C -o Pr224
Kristi @host:~/pr $/Pr223
```
- запушення ls -l для виконуваного файлу
  ```bash
  Kristi @host:~/pr $ Is l Pr224
  ```
- запущення size
    ```bash
  Kristi @host:~/pr $ size Pr224
  ```
## Результати Компіляції
```text
 Hello world!
- rwxr - xr - x 1 kristi kristi 8232 Apr 3 19:35 Pr224
text  data  bss  dec  hex  filename
1118  552  16  1686  696  Pr224
```
## Пояснення
Локальні масиви завжди зберігаються у стеку під час виконання програми. Якщо масив не ініціалізований, пам'ять для нього просто виділяється у стеку, і це не впливає на розмір виконуваного файлу.
Проте, якщо масив ініціалізований, його початкові значення додаються до текстового сегмента виконуваного файлу. 
## Умова 5 
# Компіляція для налагодження 
```bash
gcc -g -o test1 Pr244.c
ls -l test1
size test1
```
# Компіляція для оптимізвції
```bash
gcc -o3 -o test1 Pr244.c
ls -l test2
size test2
```
# Результат
```text
- rwxr - xr - x 1 kristi kristi 8944 Apr 3 20:41 test1
text  data  bss  dec  hex  filename
1118  552  16  1686  696  test1
```
```text
- rwxr - xr - x 1 kristi kristi 8192 Apr 3 20:42 test2
text  data  bss  dec  hex  filename
1073  552  16  1641  669  test2
```
## Пояснення 
При налагодженні сегменти не змінились ,змінився розмір файлу, він збільшився. Макс. оптимізація зменшила розмір текстового сегмента
# Завдання 2.3  
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі. Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси. Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?
Примітка: стек може розташовуватися за різними адресами на різних архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями адрес.

---
- Скомпільована програма
  ```text
  
  ```
