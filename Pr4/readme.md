# Завдання 4.1
## Опис програми 
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?
## Відповідь на запитання 
За один виклик у параметр malloc(3), можна виділити максимальне значення size_t. На x86_64 (64-бітна система) теоретично має розмір  ~16 ексабайтів, на практиці це ~8 ексабайтів. На x86 (32-бітна система) теоретично має розмір 4 Гб, а на практиці це може бути ще менше.

Складає 8 ескабайт а не 16, тому що, це залежить від операційної системи "У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64." 2^64 це приблизно 18446744073709551615 байт або 8 ексабайт.
Тому можемо сказати що ці ліміти виставляють самі операційні системи. 

---
# Завдання 4.2 
 ## Опис програми 
 Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.
## Компіляція 
 - на x86_64
```bash
kristi @host:~/pr/Pr4 $ gcc -m32 WalI Pr42.c -o Pr42
```
- x86
```bash
kristi @host:~/pr/Pr4 $ gcc -m64 WalI Pr42.c -o Pr42
```
## Результат компіляції
- на x86_64
```text
kristi @host:~/pr/Pr4 $ ./Pr42
malloc cannot allocate memory for a negative size 
xa = 2147483647 
num = - 2 
malloc failed 
```
- x86
```text
kristi @host:~/pr/Pr4 $ ./Pr42
malloc cannot allocate memory for a negative size 
xa = 9223372036854775807 
num = - 2 
malloc failed 
```
## Пояснення
 - Що станеться, якщо передати malloc(3) від’ємний аргумент?
  За результатами компіляціїможемо побачити, якщо ми передамо від'ємний аргумент, то функція не виділить пам'ять і поверне NULL, тому що malloc(3) очікує беззнаковий аргумент
- Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)?
  За результатами компіляції можемо побачити, що при множенні 2 - х чисел, виникає переповнення і програма виводить від'ємне число, це означає, що недостатньо пам'яті і у результаті виникає помилка.

# Завдання 4.3
## Опис програми 
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.
## Компіляція 
```bash
kristi @host:~/pr/Pr4 $ gcc -Wall Pr43.c -o Pr43 
kristi @host:~/pr/Pr4 $./Pr43
kristi @host:~/pr/Pr4 $ltrace ./Pr43
```
## Результат компіляції
```text
malloc(0) return a pointer: 0x57a0ce08008
Couldn't determi ne base address of [vdso] 
Couldn't load ELF object [vdso]: No such file or directory 
libc_start1(1, 0x8211e4db0, 0x8211e4dc0, 0x18363da17a20, 0x400652 <unfinied...> 
malloc(0)                                     = 0x3df 984208008 
printf("malloc(0) return a pointer: %p\n", 0x3df984208008malloc(0) return pointer: 0x3df 984208008 
)= 43 
free (0x3df984208008)             = <void>
+++ exited (status 0) +++ 
```
## Пояснення
Для malloc(0) поведінка залежить від реалізації .Він може повернути або NULL, або унікальний вказівник, який можна передати у free(). Запущення через ltrace, показало нам, як у malloc(0) знаходиться вказівник. І Якщо викликати free() з таким вказівником, пам'ять буде звільнена.
# Завдання 4.4
## Опис програми 
Чи є помилки у такому коді?
 ```text
  void *ptr = NULL;
  while (<some-condition-is-true>) {
      if (!ptr)
          ptr = malloc(n);
      [... <використання 'ptr'> ...]
      free(ptr);
  }
  ```
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.
## Компіляція з проблемою та правильний варіант коду 
```bash
kristi @host:~/pr/Pr4 $ gcc -Wall Pr441.c -o Pr441
kristi @host:~/pr/Pr4 $./Pr441
kristi @host:~/pr/Pr4 $ gcc -Wall Pr442.c -o Pr442
kristi @host:~/pr/Pr4 $./Pr442
```
## Результат компіляції 
- Для програми з проблемою вибило попередження, але вона скомпілювалась 
```text
  Pr441.c:15:9: warning: pointer 'ptr' used after 'free' [-Wuse-after-free] 
```
```text
Value before free: mam 
Value after free: mam 
ptr = 0x61cb6609000 
Value before free: mam 
Value after free: mam 
```
- Правильний код програми
```text
ptr = 0x61cb6609000 
Value before free: mam 
ptr = 0x61cb6609000 
Value before free: mam 
  ```
## Пояснення 
У програмі з проблемою, компілятор буде вибивати попередження use-after-free, тобто використання пам'яті після її звільнення. І по хорошому програма, мала не компілюватись. Але компілятор вважає це тільки попередженням. 
У правильному коді, ми вже після виклику free(), вказівнику ptr встановлюємо Null, щоб програма не робила повторне використання звільненої пам'яті 
# Завдання 4.5
## Опис програми
Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.
## Компіляція 
```bash
kristi @host:~/pr/Pr4 $ gcc -Wall Pr45.c -o Pr45
kristi @host:~/pr/Pr4 $./Pr45
```
## Результати компіляції 
```text
malloc: Oxcae8ea09000 
Original pointer still valid at 0xcae8ea09000 
```
## Пояснення 
Компілятор видає попередження(Walloc-size-larger-than),а не помилку тому що, аргумент (size_t)-1 перевищує максимальний допустимий розмір пам’яті. Функція realloc повертає NULL, коли їй не вдається виділити запитуваний об'єм пам'яті. Вказівник ptr, залишається незмінним і пам’ять, яка була виділена під час початкового виклику malloc(), все ще є дійсною .

# Завдання 4.6
## Опис програми
Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.
## Компіляція 
```bash
kristi @host:~/pr/Pr4 $ gcc -Wall Pr46.c -o Pr46
kristi @host:~/pr/Pr4 $./Pr46
```
## Результати компіляції 
```text
ptr1 return: 0x2c190d008008 
ptr2 return: 0x2190d008008 
```
## Пояснення 
Якщо realloc(3) викликати з NULL, то він працює так само, як malloc().Якщо realloc(3) викликати з розміром 0, то він працюєє так само, як free().Тобто realloc(3) з NULL, створює новий блок пам'яті,realloc(3) з розміром 0, звільняє пам'ять, на яку вказує ptr2.

